# 二分查找

**概念**:
二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为
0

二分查找的时间复杂度: O(logn)

---

## 二分查找的实现

### 二分查找容易出错的3个地方

1. 循环退出条件
    2. 注意是 low<=high，而不是 low
2. mid的取值
    3. 实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将
       mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算
       low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多
3. low 和 high 的更新
    4. low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当
       high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出

### 二分查找应用场景的局限性

1. 二分查找依赖的是顺序表结构，即数组。
2. 二分查找针对的是有序数据，因此只能用在插入、删除操作不频繁，一次排序多次查找的场景中。
3. 数据量太小不适合二分查找，与直接遍历相比效率提升不明显。但有一个例外，就是数据之间的比较操作非常费时，比如数组中存储的都是长度超过300的字符串，那这是还是尽量减少比较操作使用二分查找吧。
4. 数据量太大也不是适合用二分查找，因为数组需要连续的空间，若数据量太大，往往找不到存储如此大规模数据的连续内存空间

### 思考题

1. 如何在1000万个整数中快速查找某个整数？
    2. ① 1000万个整数占用存储空间为40MB，占用空间不大，所以可以全部加载到内存中进行处理；
    3. ② 用一个1000万个元素的数组存储，然后使用快排进行升序排序，时间复杂度为O(nlogn)
    4. ③ 在有序数组中使用二分查找算法进行查找，时间复杂度为O(logn)

2. 如何编程实现“求一个数的平方根”？要求精确到小数点后6位？

## 二分查找的变形问题

<img src="./img/img.png" width="500" height="auto">

### 变体一：查找第一个值等于给定值的元素

上一节中的二分查找是最简单的一种，即有序数据集合中不存在重复的数据，我们在其中查找值等于某个给定值的数据。如果我们将这个问题稍微修改下，有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据，这样之前的二分查找代码还能继续工作吗？

比如下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5
的元素。

<img src="./img/img_1.png" width="500" height="auto">

### 变体二：查找最后一个值等于给定值的元素

具体实现可以参考变体一的实现

### 变体三：查找第一个大于等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] >= value) {
      if ((mid == 0) || (a[mid - 1] < value)) return mid;
      else high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
```

### 变体四：查找最后一个小于等于给定值的元素

```java
public int bsearch7(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
```

变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 Bug，这些容易出错的细节有：**_终止条件、区间上下界更新方法、返回值选择_**。所以今天的内容你最好能用自己实现一遍，对锻炼编码能力、逻辑思维、写出 Bug free 代码，会很有帮助。

#### 思考题

leetCode33题:
https://leetcode.cn/problems/search-in-rotated-sorted-array/description/